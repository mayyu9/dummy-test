'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supportedLocales = void 0;

function generateTranslationFile(language, messages) {
  return 'import { addLocaleData } from \'react-intl\';\nimport localeData from \'react-intl/locale-data/' + language.split('-')[0] + '\';\n\naddLocaleData(localeData);\n\nconst messages = ' + JSON.stringify(messages, null, 2) + ';\n\nmodule.exports = {\n  areTranslationsLoaded: true,\n  locale: \'' + language + '\',\n  messages,\n};';
}

function getDirectories(srcPath) {
  return _fs2.default.readdirSync(srcPath).filter(function (file) {
    return _fs2.default.statSync(_path2.default.join(srcPath, file)).isDirectory();
  });
}

function aggregateDirectory(languageMessages, currentDirectory) {
  // Check the directory for translations
  var translationsDirectory = _path2.default.resolve(currentDirectory, 'translations');
  if (_fs2.default.existsSync(translationsDirectory)) {
    // Check the directory for each translation file
    supportedLocales.forEach(function (language) {
      var translationFile = _path2.default.resolve(translationsDirectory, language + '.json');
      if (_fs2.default.existsSync(translationFile)) {
        _extends(languageMessages[language], JSON.parse(_fs2.default.readFileSync(translationFile, 'utf8')));
      } else {
        // eslint-disable-next-line no-console
        console.warn('Translation file ' + language + '.json not found for ' + translationsDirectory);
      }
    });
  }

  // Check the directory's node_modules for translation files
  var nodeMoudlesPath = _path2.default.resolve(currentDirectory, 'node_modules');
  if (_fs2.default.existsSync(nodeMoudlesPath)) {
    getDirectories(nodeMoudlesPath).forEach(function (module) {
      aggregateDirectory(languageMessages, _path2.default.resolve(nodeMoudlesPath, module));
    });
  }

  return languageMessages;
}

function aggregateTranslations(options) {
  if (!options.baseDirectory) {
    throw new Error('Please included the base directory path in the plugin options.');
  }

  if (!options.supportedLocales) {
    throw new Error('Please included the supported locales in the plugin options.');
  }

  supportedLocales = options.supportedLocales;

  var languageMessages = {};
  supportedLocales.forEach(function (language) {
    languageMessages[language] = {};
  });

  // Aggregate translation messages for the directory
  languageMessages = aggregateDirectory(languageMessages, options.baseDirectory);

  // Create the aggregated-translations directory
  _mkdirp2.default.sync(_path2.default.resolve(options.baseDirectory, 'aggregated-translations'));

  // Create a file for each language for the aggregated messages
  supportedLocales.forEach(function (language) {
    if (language in languageMessages) {
      _fs2.default.writeFileSync(_path2.default.resolve(options.baseDirectory, 'aggregated-translations', language + '.js'), generateTranslationFile(language, languageMessages[language]));
    } else {
      throw new Error('Translation file found for ' + language + '.json, but translations were not loaded correctly. Please check that your translated modules were installed correctly.');
    }
  });
}

module.exports = function (options) {
  var updatedOptions = options;
  if (updatedOptions instanceof Array) {
    updatedOptions = {
      include: updatedOptions
    };
  }

  if (!Array.isArray(updatedOptions.include)) {
    updatedOptions.include = [updatedOptions.include];
  }

  return {
    apply: aggregateTranslations.bind(undefined, updatedOptions)
  };
};